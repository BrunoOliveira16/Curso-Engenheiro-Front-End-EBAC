# üìå Boas Pr√°ticas
> M√≥dulo 25: Recursos do ES6

<br>

## Conhe√ßa o Babel
### ‚úî Babel 
O Babel tamb√©m oferece suporte a plugins e presets que permitem personalizar e estender suas funcionalidades. Os plugins permitem adicionar recursos e transforma√ß√µes espec√≠ficas ao c√≥digo, enquanto os presets s√£o conjuntos pr√©-configurados de plugins que podem ser usados para transpilar para uma determinada vers√£o do ECMAScript.

### ‚úî Preset 
O Babel oferece v√°rios presets prontos para uso, como: 

- @babel/preset-env: Este √© o preset mais comumente usado. Ele permite que voc√™ especifique um conjunto de ambientes de destino (como navegadores espec√≠ficos ou vers√µes do Node.js) e, em seguida, o Babel escolhe os plugins necess√°rios com base nesses ambientes de destino. Isso permite que voc√™ escreva c√≥digo moderno do ECMAScript e o transpile para uma vers√£o compat√≠vel com os ambientes especificados. 

- @babel/preset-react: Este preset √© projetado para transpilar c√≥digo JSX usado no desenvolvimento de aplicativos React. Ele inclui os plugins necess√°rios para transformar o JSX em JavaScript v√°lido. 

- @babel/preset-typescript: Este preset √© usado para transpilar c√≥digo TypeScript para JavaScript. Ele inclui os plugins necess√°rios para lidar com as diferen√ßas de sintaxe entre TypeScript e JavaScript.

<br>

## M√©todos de arrays
> Acompanhe algumas dicas para usar os m√©todos arrays:
### ‚úî Considere a utiliza√ß√£o de m√©todos encadeados: 
Os m√©todos de arrays podem ser encadeados para realizar v√°rias transforma√ß√µes em um √∫nico fluxo de c√≥digo. Isso pode ajudar a melhorar a legibilidade e a manutenibilidade do seu c√≥digo. 

### ‚úî Esteja ciente do impacto no desempenho: 
Embora os m√©todos de arrays sejam √∫teis e expressivos, √© importante ter em mente que eles podem ter um impacto no desempenho, especialmente ao lidar com arrays muito grandes. Em alguns casos, loops tradicionais podem ser mais eficientes. Avalie o contexto e o tamanho do array em quest√£o para tomar a decis√£o adequada. 

### ‚úî Mantenha-se atualizado com as novidades do ECMAScript: 
O JavaScript est√° em constante evolu√ß√£o, com novas vers√µes do ECMAScript trazendo recursos e melhorias. Fique atualizado com as novidades do ECMAScript para aproveitar as funcionalidades mais recentes e utilizar o Babel para transpil√°-las em ambientes que ainda n√£o oferecem suporte nativo.

<br>

## Conhe√ßa a arrow function
> Arrow function: Acompanhe algumas dicas que podem ser √∫teis ao usar a arrow function
### ‚úî Verifique a compatibilidade com o ambiente de destino: 
Antes de usar arrow functions, verifique se o ambiente de destino do seu c√≥digo √© compat√≠vel com as vers√µes do ECMAScript (ES) que as suportam. Arrow functions foram introduzidas no ES6 (ES2015) e s√£o amplamente suportadas em navegadores e ambientes modernos. No entanto, se voc√™ estiver transpilando seu c√≥digo para vers√µes mais antigas do ECMAScript, como o ES5, o Babel garantir√° que as arrow functions sejam transpiladas para uma sintaxe equivalente suportada pelos ambientes de destino. 

### ‚úî Use arrow functions quando adequado: 
As arrow functions podem ser √∫teis quando voc√™ deseja uma sintaxe mais concisa para fun√ß√µes, especialmente em casos de fun√ß√µes curtas e expressivas. No entanto, lembre-se de que elas n√£o s√£o adequadas para todos os cen√°rios. Em particular, as arrow functions n√£o possuem seus pr√≥prios valores de this e n√£o s√£o adequadas para serem usadas como m√©todos de objeto. Nestes casos, √© prefer√≠vel o uso de fun√ß√µes tradicionais.

### ‚úî Mantenha a legibilidade do c√≥digo: 
Embora as arrow functions possam tornar o c√≥digo mais conciso, √© importante manter a legibilidade. Evite aninhar arrow functions excessivamente ou escrever express√µes muito longas em uma √∫nica linha. Separe o corpo da fun√ß√£o em v√°rias linhas, se necess√°rio, para melhorar a clareza do c√≥digo. 

### ‚úî Teste o c√≥digo transpilado: 
Certifique-se de testar o c√≥digo transpilado pelo Babel, especialmente em diferentes navegadores e ambientes de destino. Isso ajudar√° a garantir que as arrow functions e outras funcionalidades transpiladas estejam funcionando corretamente em todos os ambientes desejados.

<br>

> This: Quando se trata do contexto this em arrow functions, aqui est√£o algumas dicas importantes a serem consideradas

### ‚úî Heran√ßa do contexto l√©xico: 
Diferentemente das fun√ß√µes tradicionais, as arrow functions herdam o valor de this do contexto l√©xico em que est√£o definidas. Isso significa que o valor de this dentro de uma arrow function ser√° o mesmo valor de this fora dela. 

### ‚úî Evite usar arrow functions como m√©todos de objeto: 
Devido √† heran√ßa do contexto l√©xico, as arrow functions n√£o s√£o adequadas para serem usadas como m√©todos de objeto, onde geralmente se espera que this se refira ao pr√≥prio objeto. Em vez disso, use fun√ß√µes tradicionais para esses casos.

### ‚úî Use arrow functions em callbacks: 
Arrow functions s√£o particularmente √∫teis em situa√ß√µes de callbacks, como em m√©todos de array (map, filter, forEach) ou ao lidar com eventos em bibliotecas ou frameworks. Nesses casos, o contexto do this √© frequentemente capturado corretamente pela arrow function, evitando a necessidade de usar .bind() ou criar uma vari√°vel para armazenar o contexto. 

### ‚úî Se necess√°rio, use .bind() ou crie uma vari√°vel para o contexto: 
Em situa√ß√µes em que voc√™ precisa especificar explicitamente um contexto diferente para a arrow function, pode-se usar o m√©todo .bind() ou criar uma vari√°vel para armazenar o contexto desejado.

<br>

## Operadores de Spread e Rest
### ‚úî Arguments 
Arguments n√£o √© um array real, mas possui algumas caracter√≠sticas de um array, como a propriedade "length". No entanto, ele n√£o possui m√©todos de array como "forEach", "map", entre outros. Se voc√™ precisar usar m√©todos de array, pode convert√™-lo em um array real usando t√©cnicas como o spread operator ou o m√©todo "Array.from()". 

Embora a vari√°vel "arguments" seja √∫til em certos cen√°rios, o uso excessivo dela pode tornar o c√≥digo menos leg√≠vel e dificultar a manuten√ß√£o. Em muitos casos, √© prefer√≠vel usar par√¢metros de fun√ß√£o expl√≠citos para tornar o c√≥digo mais claro e previs√≠vel.

<br>

> Rest: Acompanhe algumas dicas para usar o operador rest

### ‚úî Coleta de argumentos vari√°veis: 
O operador rest √© especialmente √∫til quando voc√™ deseja criar fun√ß√µes que aceitem um n√∫mero vari√°vel de argumentos. Ele permite que voc√™ colete todos os argumentos passados para a fun√ß√£o em um √∫nico par√¢metro como um array. Isso √© √∫til quando voc√™ n√£o sabe quantos argumentos ser√£o fornecidos. 

### ‚úî Acesso aos argumentos individuais: 
Com o operador rest, voc√™ pode acessar cada argumento individualmente usando √≠ndices ou m√©todos de array. Isso permite que voc√™ trabalhe com os argumentos de maneira flex√≠vel e f√°cil. Combina√ß√£o com par√¢metros regulares: O operador rest pode ser combinado com par√¢metros regulares em uma fun√ß√£o. Os par√¢metros regulares s√£o definidos antes do par√¢metro rest e podem ser usados normalmente. 

### ‚úî Uso em desestrutura√ß√£o: 
O operador rest pode ser usado em conjunto com a desestrutura√ß√£o de arrays ou objetos para extrair valores espec√≠ficos ou restantes.

<br>

> Spread: Acompanhe algumas dicas para usar o operador spread

### ‚úî Cria√ß√£o de c√≥pias de arrays e objetos: 
O operador spread √© √≥timo para criar c√≥pias superficiais (shallow copies) de arrays e objetos, permitindo que voc√™ trabalhe com uma nova refer√™ncia sem modificar o original. 

### ‚úî Combina√ß√£o de arrays: 
O operador spread permite combinar v√°rios arrays em um √∫nico array. Mesclagem de objetos: O operador spread tamb√©m pode ser usado para mesclar m√∫ltiplos objetos em um √∫nico objeto. 

### ‚úî Passagem de argumentos para fun√ß√µes: 
O operador spread pode ser usado para passar argumentos individuais para uma fun√ß√£o que espera m√∫ltiplos argumentos. 

### ‚úî Cria√ß√£o de arrays ou objetos dinamicamente: 
O operador spread permite adicionar elementos extras a um array ou propriedades adicionais a um objeto de forma din√¢mica.

<br>

> Desestrutura√ß√£o: Acompanhe algumas dicas sobre o uso dessa funcionalidade

### ‚úî Atribui√ß√£o de valores padr√£o: 
Ao desestruturar um objeto ou array, voc√™ pode atribuir valores padr√£o a vari√°veis caso as propriedades ou elementos n√£o estejam presentes. Isso ajuda a evitar erros quando os dados s√£o incompletos ou ausentes. 

### ‚úî Alias para propriedades: 
Voc√™ pode usar a desestrutura√ß√£o para atribuir valores a vari√°veis com nomes diferentes dos das propriedades originais, criando aliases (apelidos). 

### ‚úî Desestrutura√ß√£o aninhada: 
Voc√™ pode desestruturar objetos ou arrays aninhados, permitindo acessar propriedades ou elementos internos com facilidade. 

### ‚úî Ignorar valores: 
Voc√™ pode usar a sintaxe de v√≠rgula para ignorar valores que n√£o s√£o necess√°rios na desestrutura√ß√£o. Isso √© √∫til quando voc√™ deseja extrair apenas alguns elementos de um array ou propriedades espec√≠ficas de um objeto. 

### ‚úî Par√¢metros de fun√ß√£o: 
A desestrutura√ß√£o pode ser usada para extrair valores de objetos diretamente nos par√¢metros de uma fun√ß√£o, facilitando a passagem de valores.

<br>

## Conhe√ßa as estruturas Map e Set
> Map: Acompanhe algumas dicas para o uso do conjunto map
### ‚úî Cria√ß√£o de um Map: 
Para criar um novo Map vazio, voc√™ pode usar a sintaxe new Map()

### ‚úî Adi√ß√£o de valores: 
Voc√™ pode adicionar valores ao Map usando o m√©todo set(chave, valor) 

### ‚úî Recupera√ß√£o de valores: 
Para recuperar o valor associado a uma chave espec√≠fica, use o m√©todo get(chave) 

### ‚úî Verifica√ß√£o de exist√™ncia de uma chave: 
Para verificar se uma chave existe no Map, use o m√©todo has(chave) 

### ‚úî Remo√ß√£o de um par chave-valor: 
Para remover um par chave-valor do Map, use o m√©todo delete(chave). 

### ‚úî Itera√ß√£o sobre um Map: 
O Map oferece v√°rias formas de iterar sobre seus pares chave-valor, como os m√©todos forEach, keys, values e entries. 

### ‚úî Tamanho do Map: 
Voc√™ pode obter o n√∫mero de pares chave-valor em um Map usando a propriedade size.

<br>

> Set: Acompanhe algumas dicas para o uso do conjunto set

### ‚úî Cria√ß√£o de um Set: 
Para criar um novo Set vazio, voc√™ pode usar a sintaxe new Set()

### ‚úî Adi√ß√£o de valores: 
Voc√™ pode adicionar valores ao Set usando o m√©todo add(valor) 

### ‚úî Verifica√ß√£o de exist√™ncia de um valor: 
Para verificar se um valor existe no Set, use o m√©todo has(valor) 

### ‚úî Remo√ß√£o de um valor: 
Para remover um valor do Set, use o m√©todo delete(valor) 

### ‚úî Itera√ß√£o sobre um Set: 
O Set oferece v√°rias formas de iterar sobre seus valores, como o m√©todo forEach e o uso de for...of. 

### ‚úî Tamanho do Set: 
Voc√™ pode obter o n√∫mero de valores √∫nicos em um Set usando a propriedade size. 

### ‚úî Convers√£o do Set em um Array: 
Se precisar converter um Set em um Array, voc√™ pode usar o operador spread ... ou o m√©todo Array.from().

<br>

## Programa√ß√£o Ass√≠ncrona
> Async: Acompanhe algumas dicas para usar a fun√ß√£o async
### ‚úî Utilize o async em torno da fun√ß√£o: 
Ao definir uma fun√ß√£o ass√≠ncrona, coloque a palavra-chave async antes da declara√ß√£o da fun√ß√£o. Isso indica que a fun√ß√£o ser√° ass√≠ncrona e retornar√° uma Promise. 

### ‚úî Use o await dentro da fun√ß√£o ass√≠ncrona: 
O await √© usado dentro de uma fun√ß√£o ass√≠ncrona para pausar a execu√ß√£o e esperar a resolu√ß√£o de uma Promise. Certifique-se de usar o await apenas dentro de fun√ß√µes ass√≠ncronas. Isso permite escrever c√≥digo ass√≠ncrono de forma s√≠ncrona, evitando callbacks e mantendo a legibilidade do c√≥digo. 

### ‚úî Trate erros com try...catch: 
Ao usar async e await, √© recomendado envolver o c√≥digo com um bloco try...catch. Isso permite capturar erros lan√ßados por Promises rejeitadas dentro da fun√ß√£o ass√≠ncrona. Utilize o bloco try para envolver o c√≥digo que cont√©m o await e o bloco catch para tratar os erros capturados.

### ‚úî Lide com m√∫ltiplas Promises: 
Se voc√™ estiver trabalhando com v√°rias Promises dentro de uma fun√ß√£o ass√≠ncrona, pode usar o await em cada uma delas individualmente para aguardar a resolu√ß√£o. Alternativamente, voc√™ pode usar Promise.all() para aguardar a resolu√ß√£o de v√°rias Promises ao mesmo tempo. 

### ‚úî Evite o uso excessivo de async em cadeias de chamadas: 
Embora o async possa ser √∫til em certos pontos do c√≥digo, tenha cuidado ao us√°-lo em excesso em cadeias de chamadas de fun√ß√µes. Isso pode levar a um desempenho inferior, pois cada fun√ß√£o ass√≠ncrona ter√° uma camada adicional de Promise envolvendo a execu√ß√£o.

### ‚úî Teste o c√≥digo ass√≠ncrono: 
Ao escrever c√≥digo ass√≠ncrono com async e await, √© importante testar cuidadosamente os cen√°rios ass√≠ncronos. Certifique-se de testar diferentes caminhos de execu√ß√£o, como Promises resolvidas, rejeitadas e tempos limite (timeout), para garantir que seu c√≥digo esteja lidando corretamente com essas situa√ß√µes. 

### ‚úî Esteja atento √† compatibilidade: 
Lembre-se de verificar a compatibilidade do async e await com as vers√µes do JavaScript que voc√™ est√° utilizando.

<br>

> Promise: Acompanhe algumas dicas para usar Promises de forma eficaz

### ‚úî Encadeie Promises com then(): 
Aproveite o encadeamento de m√©todos then() para executar a√ß√µes sequenciais com base no resultado de Promises anteriores. Isso permite criar um fluxo l√≥gico mais limpo e leg√≠vel. 

### ‚úî Utilize catch() para capturar erros: 
Utilize o m√©todo catch() para capturar erros nas Promises encadeadas. Isso permite tratar falhas e erros de forma centralizada e evitar que o c√≥digo pare de executar em caso de exce√ß√µes. 

### ‚úî Evite o "callback hell": 
As Promises foram introduzidas como uma alternativa ao "callback hell" (aninhamento excessivo de callbacks). Utilize Promises para lidar com opera√ß√µes ass√≠ncronas em cascata de forma mais limpa e estruturada.

### ‚úî Crie fun√ß√µes utilit√°rias reutiliz√°veis: 
Se voc√™ estiver trabalhando com opera√ß√µes ass√≠ncronas repetitivas, considere criar fun√ß√µes utilit√°rias para encapsular a l√≥gica da Promise. Isso promove a reutiliza√ß√£o de c√≥digo e mant√©m o c√≥digo mais limpo e leg√≠vel. 

### ‚úî Conhe√ßa os m√©todos auxiliares: 
Al√©m do then() e catch(), familiarize-se com outros m√©todos auxiliares de Promises, como finally(), Promise.resolve() e Promise.reject(). Esses m√©todos podem ser √∫teis em diferentes situa√ß√µes e podem aprimorar seu c√≥digo ass√≠ncrono.

### ‚úî Await 
O uso do await est√° diretamente relacionado ao conceito de Promises e fun√ß√µes ass√≠ncronas em JavaScript. Ele permite que voc√™ trabalhe com c√≥digo ass√≠ncrono de forma s√≠ncrona, tornando-o mais leg√≠vel e f√°cil de entender. No entanto, √© importante utiliz√°-lo adequadamente e compreender as implica√ß√µes do uso de fun√ß√µes ass√≠ncronas no fluxo de execu√ß√£o do c√≥digo. Acompanhe algumas dicas para us√°-lo de forma eficaz: 

- Use o await somente dentro de fun√ß√µes ass√≠ncronas: O await s√≥ pode ser usado dentro de fun√ß√µes declaradas com a palavra-chave async. Certifique-se de que a fun√ß√£o em que voc√™ est√° usando o await seja marcada como async.

### ‚úî Use o await antes de uma express√£o Promise: 
O await √© usado antes de uma express√£o Promise para pausar a execu√ß√£o da fun√ß√£o ass√≠ncrona at√© que a Promise seja resolvida. Isso permite que voc√™ aguarde o resultado de uma opera√ß√£o ass√≠ncrona antes de prosseguir. 

### ‚úî Armazene o resultado do await em uma vari√°vel: 
Ao utilizar o await, voc√™ pode atribuir o resultado da Promise a uma vari√°vel. Isso permite que voc√™ trabalhe com o resultado retornado pela Promise no restante da fun√ß√£o. 

### ‚úî Lide com erros utilizando try...catch: 
Ao utilizar o await, √© uma boa pr√°tica envolver o bloco de c√≥digo que cont√©m o await em um bloco try...catch. Isso permite que voc√™ capture erros caso a Promise seja rejeitada e trate-os de maneira adequada.

### ‚úî N√£o bloqueie o c√≥digo desnecessariamente: 
Lembre-se de que o await pausa a execu√ß√£o do c√≥digo ass√≠ncrono at√© que a Promise seja resolvida. Certifique-se de utilizar o await apenas quando for necess√°rio aguardar a conclus√£o de uma opera√ß√£o ass√≠ncrona. Caso contr√°rio, voc√™ pode bloquear desnecessariamente a execu√ß√£o do c√≥digo. 

### ‚úî Use o await em sequ√™ncia: 
O await pode ser usado em sequ√™ncia para aguardar a resolu√ß√£o de v√°rias Promises em ordem. Isso permite que voc√™ execute tarefas ass√≠ncronas em uma determinada ordem e trabalhe com os resultados conforme eles est√£o dispon√≠veis. 

### ‚úî Esteja ciente do tempo limite (timeout): 
Ao usar o await, especialmente em chamadas de API, considere definir um tempo limite para evitar que o c√≥digo fique bloqueado indefinidamente caso a Promise n√£o seja resolvida em um per√≠odo razo√°vel de tempo. Voc√™ pode fazer isso usando Promise.race() com uma Promise de tempo limite.

<br>

## Orienta√ß√µes a Objetos com ES6
> Extends: Essa palavra reservada √© uma parte essencial da heran√ßa em JavaScript, permitindo a cria√ß√£o de hierarquias de classes e a reutiliza√ß√£o de c√≥digo. Acompanhe algumas dicas para us√°-la de forma eficaz
### ‚úî Planeje a hierarquia de classes: 
Ao usar o extends, √© necess√°rio planejar adequadamente a hierarquia de classes. Considere como as classes est√£o relacionadas entre si e se a rela√ß√£o de heran√ßa √© apropriada para o problema que voc√™ est√° resolvendo. 

### ‚úî Defina uma classe pai adequada: 
Escolha uma classe adequada para servir como a classe pai na hierarquia de classes. A classe pai deve conter as caracter√≠sticas e comportamentos comuns que podem ser compartilhados pelas classes filhas. 

### ‚úî Aproveite os m√©todos e propriedades herdados: 
Ao usar o extends, voc√™ pode acessar os m√©todos e propriedades da classe pai por meio da inst√¢ncia da classe filha usando a palavra-chave super. Isso permite que voc√™ reutilize e estenda o comportamento da classe pai.

### ‚úî Adicione m√©todos e propriedades espec√≠ficos da classe filha: 
Aproveite a capacidade de adicionar m√©todos e propriedades espec√≠ficos da classe filha para personalizar seu comportamento. Isso permite que voc√™ estenda e especialize a funcionalidade herdada da classe pai. 

### ‚úî Evite heran√ßas profundas e complexas: 
Tenha cuidado ao criar hierarquias de classes profundas e complexas. Muitos n√≠veis de heran√ßa podem levar a um c√≥digo mais dif√≠cil de entender e manter. Considere utilizar outros princ√≠pios de design, como composi√ß√£o, quando a heran√ßa se tornar muito complexa.

<br>

> Super: O super √© usado para garantir que a funcionalidade da classe pai seja reutilizada ou estendida na classe filha, fornecendo uma maneira de manter uma rela√ß√£o de especializa√ß√£o entre as classes. Acompanhe algumas dicas para us√°-lo de forma eficaz

### ‚úî Chame o construtor da classe pai: 
Ao usar super() no construtor da classe filha, lembre-se de chamar o construtor da classe pai. Isso √© importante para garantir que as propriedades da classe pai sejam inicializadas corretamente antes de adicionar as propriedades da classe filha. 

### ‚úî Use super para acessar m√©todos da classe pai: 
A palavra-chave super permite acessar os m√©todos da classe pai a partir da classe filha. Use super.nomeDoMetodo() para chamar o m√©todo da classe pai. Isso √© √∫til quando voc√™ quer estender o comportamento da classe pai na classe filha. 

### ‚úî Aproveite super para acessar propriedades da classe pai: 
Voc√™ pode usar super para acessar as propriedades da classe pai na classe filha. Isso permite que voc√™ acesse ou sobrescreva propriedades espec√≠ficas da classe pai dentro da classe filha.

### ‚úî Utilize super no contexto apropriado: 
Lembre-se de usar super apenas dentro da classe filha, pois ele n√£o ter√° significado fora do contexto da heran√ßa. Tenha cuidado para n√£o usar super onde n√£o √© necess√°rio ou onde n√£o faz sentido. 

### ‚úî Aplique o super em sobrescri√ß√µes de m√©todos: 
Ao sobrescrever um m√©todo da classe pai na classe filha, voc√™ pode usar super para chamar o m√©todo original da classe pai. Isso permite que voc√™ estenda o comportamento da classe pai sem perder a funcionalidade original.

### ‚úî Utilize super com cautela: 
Embora super seja uma ferramenta poderosa para acessar membros da classe pai, √© importante us√°-lo com cautela. Considere se a heran√ßa √© a abordagem correta para o problema que voc√™ est√° resolvendo e avalie se a rela√ß√£o de heran√ßa √© apropriada para o caso em quest√£o. 

### ‚úî Evite refer√™ncias circulares: 
Evite criar refer√™ncias circulares entre classes pai e filha, onde a classe filha tamb√©m √© uma classe pai de outra classe. Isso pode levar a um c√≥digo confuso e dif√≠cil de manter. Em vez disso, procure seguir uma hierarquia de heran√ßa clara e evite depend√™ncias complexas.